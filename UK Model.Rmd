---
title: "UK Model"
output: html_document
---


```{r library, message=FALSE}
rm(list = ls())
library(dplyr)
library(epidemia)
library(rstanarm)
library(httr)
library(jsonlite)
library(Hmisc)
library(knitr)
library(lubridate)
```
GET data

```{r GET}
# API request
AREA_TYPE = "nation"
AREA_NAME = "england"

endpoint <- "https://api.coronavirus.data.gov.uk/v1/data"

# Create filters:
filters <- c(
  sprintf("areaType=%s", AREA_TYPE),
  sprintf("areaName=%s", AREA_NAME)
)

# Create the structure as a list or a list of lists:
structure <- list(
    Nation = "areaName",
    date = "date", 
    cases = "newCasesByPublishDate",
    cumulativeCases = "cumCasesByPublishDate",
    dailyDeaths = "newDeaths28DaysByPublishDate", 
    # newDailyNsoDeathsByDeathDate
    cumulativeDeaths = "cumDeaths28DaysByPublishDate",
    # cumDailyNsoDeathsByDeathDate
    # Patients in hospital
    hospital = "hospitalCases",
    ventilationbeds = "covidOccupiedMVBeds",
    newfirstVaccination = "newPeopleVaccinatedFirstDoseByPublishDate",
    cumfirstVaccination = "cumPeopleVaccinatedFirstDoseByPublishDate",
    newsecondVaccination = "newPeopleVaccinatedSecondDoseByPublishDate",
    cumsecondVaccination = "cumPeopleVaccinatedSecondDoseByPublishDate"
)

response <- GET(
  url = endpoint,
  query = list(
        filters = paste(filters, collapse = ";"),
        structure = jsonlite::toJSON(structure, auto_unbox = TRUE)
    ),
  content_type("application/json"),
  timeout(10)
) 

# Handle errors:
if (response$status_code >= 400) {
    err_msg = httr::http_status(response)
    stop(err_msg)
}

# Convert response from binary to JSON:
json_text <- content(response, "text")
data      <- fromJSON(json_text)$data

pop.fun <- function(date) {
  pop.2019 <- 67530172
  pop.2020 <- 67886011
  rate.day <- log(pop.2020/pop.2019)/365
  diff.day <- as.numeric(difftime(date, '2020-01-01'))
  return(round(pop.2019 * exp(rate.day*diff.day)))
}
data$pop <- lapply(data$date, pop.fun)
data$pop <- as.numeric(data$pop)
data <- data[-1,]
kable(head(data))

# as index
data$date <- as.Date(data$date)
rownames(data) <- data$date
```
```{r impute data}
for (d in row.names(data)) {
  differ = as.numeric(difftime(d, '2020-12-8'))
  if (differ < 0) {
    data[
      d, c(
        "newfirstVaccination", "cumfirstVaccination",
        "newsecondVaccination", "cumsecondVaccination"
        )] <- c(0,0,0,0)
  }
}
```

```{r Uniform distributed}
for (d in row.names(data)) {
  if (is.na(data[d, "cumfirstVaccination"])) {
    differ.all = as.numeric(difftime('2021-01-10', '2020-12-7'))
    differ = as.numeric(difftime(d, '2020-12-7'))
    cum <- data['2021-01-10', "cumfirstVaccination"] / differ.all
    data[d, "cumfirstVaccination"] <- round(cum * differ)
  }
}
for (d in row.names(data)) {
  if (is.na(data[d, "newfirstVaccination"])) {
    cum <- data[d, "cumfirstVaccination"]
    x <- ymd(d)
    day(x) <- day(d) - 1
    x <- as.character(x)
    data[d, "newfirstVaccination"] <- cum - data[x, "cumfirstVaccination"]
  }
}
for (d in row.names(data)) {
  if (is.na(data[d, "cumsecondVaccination"])) {
    if (difftime(d, '2021-01-04') > 0) {
      differ.all = as.numeric(difftime('2021-01-10', '2021-01-04'))
      differ = as.numeric(difftime(d, '2021-01-04'))
      cum <- data['2021-01-10', "cumsecondVaccination"] / differ.all
      data[d, "cumsecondVaccination"] <- round(cum * differ)
    } else {
      data[d, "cumsecondVaccination"] <- 0
    }
  }
}
for (d in row.names(data)) {
  if (is.na(data[d, "newsecondVaccination"])) {
    cum <- data[d, "cumsecondVaccination"]
    x <- ymd(d)
    day(x) <- day(d) - 1
    x <- as.character(x)
    data[d, "newsecondVaccination"] <- cum - data[x, "cumsecondVaccination"]
  }
}
```

```{r vaccination rate}
data$FirstVaccinationRate = data$cumfirstVaccination / data$pop
data$SecondVaccinationRate = data$cumsecondVaccination / data$pop
```

add the public isolation to the data

1. school and university lock down at Mar $21^{st}$ 2020

2. self-isolation if ill at Mar $12^{th}$ 2020

3. public events forbidden at Mar $24^{th}$ 2020

4. lock down at Mar $24^{th}$ 2020

5. social distance encouraged at Mar $16^{th}$ 2020

```{r isolation}
data$schools_universities <- 0
data$self_isolating_if_ill <- 0
data$social_distancing_encouraged <- 0
data$public_events <- 0
data$lockdown <- 0
for (d in row.names(data)) {
  if (as.numeric(difftime(d, '2020-03-11')) > 0) {
    data[d,"self_isolating_if_ill"] <- 1
    if (as.numeric(difftime(d, '2020-03-15')) > 0) {
      data[d,"social_distancing_encouraged"] <- 1
      if (as.numeric(difftime(d, '2020-03-20')) > 0) {
        data[d,"schools_universities"] <- 1
        if (as.numeric(difftime(d, '2020-03-23')) > 0) {
          data[d,"public_events"] <- 1
          data[d,"lockdown"] <- 1
        } 
      } 
    } 
  } 
}
```




seeding begins in each country 30 days prior to observing 10 cumulative deaths

the population data is incorrect, the 2020 population is 67,886,011, the population should be adjusted (3-year rate is 0.53% 0.58% 0.62%)



# $R_0$
```{r r0}
rt <- epirt(
  formula = R(Nation, date) ~ 
    0  + public_events + schools_universities + self_isolating_if_ill + social_distancing_encouraged + lockdown + FirstVaccinationRate + SecondVaccinationRate,
  prior = shifted_gamma(shape=1/6, scale = 1, shift = log(1.05)/6),
  prior_covariance = decov(shape = c(2, rep(0.5, 5)),scale=0.25),
  link = scaled_logit(6.5)
)
```

```{r MCMC, message=FALSE}
data("EuropeCovid2")
obs <-  epiobs(
    formula = cases ~ 1,
    prior_intercept = rstanarm::normal(location=1, scale=0.01),
    link = "identity",
    i2o = rep(.25,4)
)
args <- list(
  rt = rt,
  inf = epiinf(gen = EuropeCovid2$si),
  obs = obs,
  
  
  data = data,
  iter = 1e2,
  seed = 12345
)
fm1 <- do.call(epim, args)
plot_rt(fm1)
```

